## 第44条 正确运用fake、stub和mock等辅助单元测试

你不需要一个真实的数据库来满足运行单元测试的需求。—— 佚名

在某些情况并不需要所有依赖的真实组件就绪才能进行测试，而是可以用其他的一些工具如fake、stub、mock等进行替代，从而在真实环境缺少的情况下进行模拟。

## 44.1 fake：真实组件或服务的简化实现版替身

fake测试指采用真实组件或服务的简化版实现作为替身，以满足被测代码的外部依赖需求。比如：当被测代码需要连接数据库进行相关操作时，可以使用一个**伪数据库**作为替身。

比如在database/sql中：

```go
func TestUnsupportedOptions(t *testing.T) {
    db := newTestDB(t, "people")
    defer closeDB(t, db)
    _, err := db.BeginTx(context.Background(), &TxOptions{
        Isolation: LevelSerializable, ReadOnly: true,
    })
    if err == nil {
        t.Fatal("expected error when using unsupported options, got nil")
    }
}

const fakeDBName = "foo"

func newTestDB(t testing.TB, name string) *DB {
    return newTestDBConnector(t, &fakeConnector{name: fakeDBName}, name)
}

func newTestDBConnector(t testing.TB, fc *fakeConnector, name string) *DB {
    fc.name = fakeDBName
    db := OpenDB(fc)
    if _, err := db.Exec("WIPE"); err != nil {
        t.Fatalf("exec wipe: %v", err)
    }
    if name == "people" {
        exec(t, db, "CREATE|people|name=string,age=int32,photo=blob,dead=bool,
            bdate=datetime")
        exec(t, db, "INSERT|people|name=Alice,age=?,photo=APHOTO", 1)
        exec(t, db, "INSERT|people|name=Bob,age=?,photo=BPHOTO", 2)
        exec(t, db, "INSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?", 3, chrisBirthday)
    }
    if name == "magicquery" {
        exec(t, db, "CREATE|magicquery|op=string,millis=int32")
        exec(t, db, "INSERT|magicquery|op=sleep,millis=10")
    }
    return db
}
```

自定义实现的fake：

```go
type fakeOkMailer struct{}
func (m *fakeOkMailer) SendMail(subject string, dest string, body string) error {
    return nil
}

type fakeFailMailer struct{}
func (m *fakeFailMailer) SendMail(subject string, dest string, body string) error {
    return fmt.Errorf("can not reach the mail server of dest [%s]", dest)
}
```

替身在测试中的使用方法：

```go
func TestComposeAndSendOk(t *testing.T) {
    m := &fakeOkMailer{}
    mc := mailclient.New(m)
    _, err := mc.ComposeAndSend("hello, fake test", []string{"xxx@example.com"}, "the test body")
    if err != nil {
        t.Errorf("want nil, got %v", err)
    }
}

func TestComposeAndSendFail(t *testing.T) {
    m := &fakeFailMailer{}
    mc := mailclient.New(m)
    _, err := mc.ComposeAndSend("hello, fake test", []string{"xxx@example.com"}, "the test body")
    if err == nil {
        t.Errorf("want non-nil, got nil")
    }
}
```

使用fake时需要预设返回值，即无论调用多少次，传入什么参数，返回值都是一个。

## 44.2 stub：对返回结果有一定预设控制能力的替身

stub也是一种替身概念，和fake替身相比，stub替身增强了对替身返回结果的间接控制能力，这种控制可以通过测试前对调用结果预设置来实现。不过，stub替身通常仅针对计划之内的结果进行设置，对计划之外的请求也无能为力。

github中https://github.com/prashantv/gostub哭用于简化stub替身管理和编写。如：

```go
func TestComposeAndSendWithSign(t *testing.T) {
    sender := "tonybai@example.com"
    timestamp := "Mon, 04 May 2020 11:46:12 CST"

    stubs := gostub.Stub(&getSign, func(sender string) string {
        selfSignTxt := senderSigns[sender]
        return selfSignTxt + "\n" + timestamp
    })
    defer stubs.Reset()
    ...
}
```

## 44.3 mock：专用于行为观察和验证的替身

mock替身提供测试钱的预设值返回结果能力，还可以对mock替身对象在测试过程中的行为进行观察和验证。不过mock存在一些应用局限：

和前两种替身相比，mock的应用范围只用于实现某接口的实现类型的替身。

一般需要通过第三方框架实现mock替身。Go官方维护了一个mock框架 — gomock(https://github.com/golang/mock)，该框架通过代码生成的方法实现某接口类型。

先下载mockgen，

```go
$go get github.com/golang/mock/mockgen
```

然后在源码文件开始处执行：

```go
//go:generate mockgen -source=./mailer.go -destination=./mock_mailer.go -package=mailer Mailer

package mailer

type Mailer interface {
    SendMail(subject, sender, destination, body string) error
}
```

接下来在mocktest目录下，执行go generate命令以生成mailer.Mailer接口实现的替身。执行go generate命令后，会在mocktest/mailer目录下看到一个新的文件 —— mock_mailer.go。

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: ./mailer.go

// mailer包是一个自动生成的 GoMock包
package mailer

import (
    gomock "github.com/golang/mock/gomock"
    reflect "reflect"
)

// MockMailer是Mailer接口的一个模拟实现
type MockMailer struct {
    ctrl     *gomock.Controller
    recorder *MockMailerMockRecorder
}

// MockMailerMockRecorder 是 MockMailer的模拟recorder
type MockMailerMockRecorder struct {
    mock *MockMailer
}

// NewMockMailer创建一个新的模拟实例
func NewMockMailer(ctrl *gomock.Controller) *MockMailer {
    mock := &MockMailer{ctrl: ctrl}
    mock.recorder = &MockMailerMockRecorder{mock}
    return mock
}

// EXPECT返回一个对象，允许调用者指示预期的使用情况
func (m *MockMailer) EXPECT() *MockMailerMockRecorder {
    return m.recorder
}

// SendMail模拟基本方法
func (m *MockMailer) SendMail(subject, sender, destination, body string) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "SendMail", subject, sender, destination, body)
    ret0, _ := ret[0].(error)
    return ret0
}

// SendMail表示预期的对SendMail的调用
func (mr *MockMailerMockRecorder) SendMail(subject, sender, destination, body interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMail", reflect.TypeOf((*MockMailer)(nil).SendMail), subject, sender, destination, body)
}
```

```go
package mailclient

import (
    "errors"
    "testing"

    "github.com/bigwhite/mailclient/mailer"
    "github.com/golang/mock/gomock"
)

var senderSigns = map[string]string{
    "tonybai@example.com":  "I'm a go programmer",
    "jimxu@example.com":    "I'm a java programmer",
    "stevenli@example.com": "I'm a object-c programmer",
}

func TestComposeAndSendOk(t *testing.T) {
    old := getSign
    sender := "tonybai@example.com"
    timestamp := "Mon, 04 May 2020 11:46:12 CST"

    getSign = func(sender string) string {
        selfSignTxt := senderSigns[sender]
        return selfSignTxt + "\n" + timestamp
    }
    defer func() {
        getSign = old //测试完毕后，恢复原值
    }()

    mockCtrl := gomock.NewController(t)
    defer mockCtrl.Finish() //Go 1.14及之后版本中无须调用该Finish

    mockMailer := mailer.NewMockMailer(mockCtrl)
    mockMailer.EXPECT().SendMail("hello, mock test", sender,
     "dest1@example.com",
     "the test body\n"+senderSigns[sender]+"\n"+timestamp).Return(nil).Times(1)
    mockMailer.EXPECT().SendMail("hello, mock test", sender,
     "dest2@example.com",
     "the test body\n"+senderSigns[sender]+"\n"+timestamp).Return(nil).Times(1)

    mc := New(mockMailer)
    _, err := mc.ComposeAndSend("hello, mock test",
      sender, []string{"dest1@example.com", "dest2@example.com"}, "the test body")
    if err != nil {
        t.Errorf("want nil, got %v", err)
    }
}
```

重点代码是：

```go
mockMailer.EXPECT().SendMail("hello, mock test", sender,
    "dest1@example.com",
    "the test body\n"+senderSigns[sender]+"\n"+timestamp).Return(nil).Times(1)
```

出了gomock框架之外，社区还有go-sqlmock（https://github.com/DATA-DOG/go-sqlmock），专门用于创建sql/driver包中的Driver接口实现的mock替身。

## 44.4 总结

1. fake多用于构造一个真实服务的替身
2. stub替身具有有限范围的、在测试前预置返回结果的控制能力
3. mock多用于行为观察的替身，一般用作Go接口