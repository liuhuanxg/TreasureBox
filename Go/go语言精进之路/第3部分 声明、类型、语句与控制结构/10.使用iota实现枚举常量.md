# 第10条 使用iota实现枚举常量

Go在声明常量时提供了“隐式重复前一个非空表达式”的机制，如：

```go
const (
	a1, a2= 1,2
	a3, a4
	a5, a6
) 
// a3,a4和a5,a6虽然没赋值，但都复制了上一个的表达式，初始值都是1和2
```

但是这种用法仍然无法满足枚举的要求，因此，go在这个基础上提供了`iota`神器。有了iota，就可以定义满足各种场景的枚举常量。

`iota`是Go语言中的一个预定义标识符，标识的是const声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的iota自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。

如：

```go
const (
	t1 = iota
	t2
	t3
	t4
)
// 分别表示 0 1 2 3
```

同时，在同一行中的iota表示的值相同，如

```go
const (
	t6, t7 = iota, iota + 10
)
// 分别表示0和10
```

iota默认从0开始，如果不想要0值，可以用：

```go
const (
	_ = iota
	t9
	t10
	t11
)
// t9、t10、t11分别表示1，2，3
```

或者也可以用:

```go
const (
	t9 = iota + 1
	t10
	t11
)
```

如果中间某几个值不想要时可以用`_`跳过。

iota的加入让Go在枚举常量定义上的表达力大增，主要体现在如下方面：

1. iota预定义标识符能更为灵活的形式为枚举常量赋初值
2. Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量
3. iota使得维护枚举常量列表更容易
4. 使用有类型枚举常量保证类型安全