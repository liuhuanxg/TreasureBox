# 第16条 理解Go语言的包导入

Go语言使用包(package)作为基本单元组织源码。以包为基本构建单元的构建模型使依赖分析变得十分简单，避免了C语言那种通过头文件分析依赖的巨大开销。编译速度快是go语言头文件包含机制的先进性表现之一。编译速度快体现在以下三个方面：

1. Go语言要求每个源文件在开头处显式列出所有依赖的包导入，这样Go编译器不必读取和处理整个文件就可以确定其依赖的包列表。
2. Go语言要求包之间不能存在循环依赖，这样一个包的依赖关系便形成了一张有向无环图。由于无环，包可以单独编译，也可以并行编译。
3. 已编译的go包对应的目标文件（file_name.o或package_name.a）中不仅记录了该包本身的导出符号信息，还记录了其所依赖包的导出符号信息。这样go编译器在编译某包P时，针对P依赖的每个包导入（比如导入包Q），只需要读取一个目标文件即可（比如：Q包编译成的目标文件中已经包含Q包的依赖包的导出信息），而无需再读取其他文件中的信息。

Go语言中包的定义使用package关键字声明：

```go
// xx.go
package a
```

使用import关键字导入依赖的标准库包或第三方包：

```go
package main

import (
	"fmt"
	"github.com/nsqio/go-nsq"
)

func main() {
	fmt.Println(nsq.NewConfig())
}
```

在上述例子中，虽然导入的是`go-nsq`，但是在使用时为`nsq.`这是因为go的特殊导入方式决定，那导入的是路径名出还是包名？具体答案如下。

## 16.1 Go程序构建过程

和主流静态编译型语言一样，Go程序的构建简单来讲也是由编译（compile）和链接（link）两个阶段组成。

一个非main包在编译后对应一个.a文件，该文件可以理解为Go的目标文件，该目标文件是通过pack工具($GOROOT/pkg/tool/drawin_amd64/pack)对.io文件打包后形成的。默认情况下，在编译过程中.a文件生成在临时目录下，除非使用go install安装到$GOPATH/pkg下，否则看不到.a文件。如果构建可执行程序，.a文件会在构建可执行程序的链接阶段起作用。

标准库源码文件在$GOROOT/src下面，对应的.a文件存放在$GOROOT/pkg/darwin_amd64下(Mac系统中)。

```shell
➜  ~ ll /usr/local/go/pkg/darwin_amd64

total 61096
drwxr-xr-x   4 root  wheel   128B  8 17  2023 archive
-rw-r--r--   1 root  wheel   379K  8 17  2023 bufio.a
-rw-r--r--   1 root  wheel   453K  8 17  2023 bytes.a
drwxr-xr-x   7 root  wheel   224B  8 17  2023 compress
drwxr-xr-x   5 root  wheel   160B  8 17  2023 container
-rw-r--r--   1 root  wheel   210K  8 17  2023 context.a
drwxr-xr-x  22 root  wheel   704B  8 17  2023 crypto
-rw-r--r--   1 root  wheel    56K  8 17  2023 crypto.a
drwxr-xr-x   4 root  wheel   128B  8 17  2023 database
...
```

**那么构建Go程序时，编译器会重新编译依赖包的源文件还是直接链接包的.a文件呢？**

在使用第三方包的时候，在第三方包源码存在且对应的.a已安装的情况下，编译器链接的**仍是根据第三方包最新源码编译出的.a文件**，而不是之前已经安装到$GOPATH/pkg/darwin_amd64下的目标文件

想要观察go代码的构建过程可以在go build时候加上-x和-v参数。

Go所谓的使用第三方包源码，实际上是链接了以该最新包源码编译的、存放在临时目录下的包的.a文件而已。

**如果是Go标准库中的代码，是使用`$GOPATH/pkg`下的.a文件，还是`$GOPATH/src`下的源**码呢？

标准库中的代码在编译时需要标准库中的源码，但是在默认情况下链接时链接的还是`$GOPATH/pkg`下的.a文件。

那么如何让修改的标准库中的代码生效？

1. 删除`$GOPATH/pkg`下的.a文件，然后重新执行go install fmt
2. 在go build时加上-a命令行选项：-a选项会让所有的依赖包（直接的或间接的）都重新编译一遍。

## 16.2 究竟是路径名还是包名

**编译器在编译过程中必然要使用的是编译单元（一个包）所依赖的包的源码**。而编译器要找到依赖包的源码文件，就需要知道依赖包的源码路径，这个路径由两部分组成：**基础搜索路径**和**包导入路径**。

基础搜索路径：

1. 所有包（无论是标准库还是第三方包）的源码基础搜索路径都包括$GOROOT/src
2. 在基础路径基础上，不同版本的Go包函的其他基础搜索路径不同
   1. Go 1.11版本之前，包的源码基础搜索路径还包括$GOPATH/src
   2. Go 1.11 ~ Go 1.12版本，包的源码基础搜索路径有三种模式：
      1. 经典gopath模式下（GO111MODULE=off）：$GOPATH/src。
      2. module-aware模式下（GO111MODULE=on）：$GOPATH/pkg/mod。
      3. auto模式下（GO111MODULE=auto）：在$GOPATH/src路径下，与gopath模式相同；在$GOPATH/src路径外且包含go.mod，与module-aware模式相同。
3. Go 1.13版本，包的源码基础搜索路径有两种模式：
   1. 经典gopath模式下（GO111MODULE=off）：$GOPATH/src。
   2. module-aware模式下（GO111MODULE=on/auto）：$GOPATH/pkg/mod。
4. 未来的Go版本将只有module-aware模式，即只在module缓存的目录下搜索包的源码。

搜索路径的第二部分就是位于每个包源码文件头部的包导入路径。基础搜索路径与包导入路径结合在一起，Go编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间

因此，可以得到一个结果：**源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名**。

不过Go语言有一个惯用法：**包导入路径的最后一段目录名最好与包名一致**。

虽然导入时和使用时名称可能一样，但是含义不同：**导入时的名称是一个目录名，使用时的包名才是一个包名**。

关于包导入，Go语言还有一个惯用法：当包名与包导入路径中的最后一个目录名不同时，最好给导入的包显示起一个别名，提高代码的可读性。如:

```go
import (
	"fmt"
	nsq "github.com/nsqio/go-nsq"
)

func main() {
	fmt.Println(nsq.NewConfig())
}
```

## 16.3 包名冲突问题

在go语言中允许导入的包名路径不同，但如果包名冲突时需要显式指定包名以避免冲突，不然会编译报错。

## 16.4 总结

1. Go编译器在编译过程中必然要使用的是编译单元（一个包）所依赖的包的源码
2. Go源码中头部导入的import后的是一个目录名字，而不是一个包名
3. go编译器的源码搜索路径由基本搜索路径和包导入路径组成。两者结合才可确定一个包的所有依赖包的源码路径的集合。
4. 同一源码文件依赖包名冲突时可通过显式指定包名方式解决