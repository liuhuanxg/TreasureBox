# 递归

递归：在函数中自己调用自身，类似于压栈

递归三要素：

1. 递归边界：一定要有终止条件
2. 逻辑处理
3. 调用自身
4. 状态清理

例如：

斐波那契

某个数的阶乘

## 分治：Divde & Conquer

分而治之：将一个大问题依次解决，类似于庖丁解牛。

经典算法：二分查找、快排

## 贪心算法

简单来说：问题能够分解成子问题来解决，子问题的最优解能递推到最终的最优解，这样子问题最优解称为最优子结构。

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 广度优先算法

Breadth First Search

在树（图/状态集）中查找特定节点

每层推进的过程中没有重复的，先扫描某个节点时，将该节点的所有子节点全部加入，以作为下次继续推进。

又称为地毯式搜索

## 深度优先

Depth First Search

每层推进的过程中没有重复的，先扫描某个节点时，将某个节点一直扫描到叶子节点之后，再扫描该节点的其他节点。

## 二分查找

1. 单调递增或递减
2. 存在上下界
3. 能够通过索引访问

## 位运算

什么是位运算：程序中所有数在计算机内存中都是以二进制的形式储存的。位运算说白了就是对证书在内存中的二进制位进行操作。比如：and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子：6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它的二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）：

```
110 AND 1011 >> 0010(b)——> 2(d)
```

由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同时为0，相异为1                                     |
| -    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进制位全部左移若敢为，高位丢弃，低位补0                  |
| >>   | 右移 | 各二进制位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方式不一样，有的补符号位(算数右移)，有的补0（逻辑右移） |

## 动态规划(Dynamic Programming)

动态规划分为4个思路：

1. 递归+记忆化 ——> 递推
2. 状态的定义：opt[n]，dp[n]，fib[n]
3. 状态转移方程：opt[n] = best_of(opt[n-1],opt[n-2],...)
4. 最优子结构

先规划最基础的一步怎么执行，然后逐层反推，得到最优的方案

## DP vs 回溯 vs 贪心

- 回溯（递归）—— 重复计算，尽可能考虑重复计算问题，减少重复计算
- 贪心 —— 永远局部最优
- DP —— 记录局部最优子结构 / 多种记录值

## 并查集

并查集(union & find)是一种树形的数据结构，用于处理一些不交集(Disjoint Sets)的合并及查询问题

Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集

union：将两个子集合并为同一个集合。

示例，给定一串数组`1 2 3 4 5 6 7 8 `

拆分为`1 2 5 6 8` `3 4` `7`子集形式

##### 生活中的例子

1. 小弟——> 老大
2. 帮派识别
3. 两种优化方式：并查集的深度成为rank
   1. 将rank低的合并到rank高的并查集中
   2. 进行读路径优化：将`d c b a a`路径全部压缩为`d a`,`c a`,`b a`,`a a`

## Cache 缓存

1. 记忆
2. 钱包——储物柜
3. 代码模块

## LRU Cache

1. Least recently used（最近最少使用）
2. Double LinkedList
3. O(1)查询，查询最近的数据是O(1)
4. O(1)修改

## LFU Cache

1. LFU ——least frequently used 最近最不常用页面置换算法
2. LRU——least recently used 最近最少使用页面置换算法

## Bloom Filter 布隆过滤器

一个很长的二进制向量和一个映射函数

布隆过滤器可以用于检索一个元素是否在一个集合中

他的优点是空间效率和查询效率远远超过一般算法，缺点是有一定的误识别率和删除困难

误识别率：数据存在时会出现误判，不存在时一定不存在

删除困难：哈希之后的结果不好删除，可能会误删其他元素的值

案例：

1. 比特币
2. 分布式系统（Map-Reduce）

## 现实中的算法问题

适用于找房子，找女朋友，吃饭等等选择问题。

假设1年找2个女朋友，

1. 如果能选择之前的，O(n)
2. 如果不能后悔，则用37%原则

其他：

1. Priority Queue 一个任务的密度=重要程度/完成时间
2. Kelly Formula 凯利公式
3. Game Theory 博弈论

## 代码模版

1. 递归
2. DFS：深度优先遍历
3. BFS：广度优先遍历
4. 二分查找
5. DP方程 

## 练习和切题

**持续练习+精深练习（刻意练习）**

1. 除了做熟悉的题和会做的题之外，去刻意练习自己不熟悉的算法和数据结构，不要为了切题而切题
2. 做过的题目后续要返回再复习

## 面试答题四件套

1. Clarification 询问题目细节、边界条件、可能的极端错误
2. Possible Solution 所有可能的解法都和面试官沟通一下
   1. 时间复杂度 & 空间复杂度
   2. 最优解
3. Coding 写代码
4. Test Cases 测试用例

 **沟通和交流很重要**

## 最后

常学常新

