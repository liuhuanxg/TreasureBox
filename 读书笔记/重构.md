# 重构

在不改变代码外在行为的前提下，对代码作出修改，以改进程序内部结构。

本质上说：重构就是在代码写好之后改进它的设计。

## 第一个重构

需求的变化使重构变得必要，如果代码能正常工作，并且不会再被修改，完全可以不去重构。

**重构的第一步**：确保即将修改的代码拥有可靠的测试。

**重构的精髓**：小步修改，每次修改之后就运行测试。

傻瓜都能写出计算机可以理解的代码，唯有写出人类能理解的代码，才是优秀的程序员。

重构的方法：通过减少代码量，减少函数长度，对函数拆分，将函数变量改变为函数声明，把复杂的代码块分解为更小的单元。

编程时需要遵守营地法则：保证离开时，一定比来时更健壮。完美的境界很难达到，但应该勤加拂拭。

好代码的标准就是轻易找到修改点。

## 第二章 重构的原则

**重构**：对软件内部结构调整，在不改变软件可观察前提下，提高其可理解性，降低代码修改成本。

两顶帽子：添加新功能和重构，应该是交替进行而不是并行。

**为何重构**：

1. 重构改进软件的设计
2. 重构使软件更容易理解
3. 重构帮助快速找到bug
4. 重构提高编程速度

**何时重构**：

1. 三次法则：重复做一件事三次以上时
2. 预备性重构：让新添加功能更容易
3. 帮助理解的重构，让代码更易懂
4. 捡垃圾式重构，每次捡一点点
5. 有计划的重构和见机行事的重构
6. 长期重构
7. 复审代码时重构

怎么说服别人重构：设计耐久性假说，一个程序及时不动，内部墒也在不断增加。

何时不应该重构：与本次修改无关时，并且重构比新实现更难。

**重构的挑战**：

1. 延缓新功能开发
2. 代码所有权：很难同时对所有涉及的代码修改
3. 协同开发：修改一个方法时造成冲突
4. 测试：保证不会改变程序的可观察行为
5. 遗留代码
6. 数据库：字段重修改时需要所有使用方都修改
7. 重构与性能的取舍：重构之后的代码更易于改造

## 第三章 代码中的坏味道

1. 神秘命名：见名知义
2. 重复代码：对代码提炼
3. 过长函数：对函数分解
4. 过长参数列表：适用对象取代
5. 全局数据：对变量封装
6. 可变数据：对变量的修改进行封装
7. 发散式修改：修改代码时只修改某处
8. 霰弹式修改：将代码拆分合并，防止同时修改很多地方
9. 依恋情结：将数据和引用这些数据的行为放在一起
10. 数据泥土：提炼为类
11. 基本类型偏执：提炼类和引入参数对象，减少基本类型使用
12. 重复的switch：使用多态类来替代
13. 循环语句：使用高阶函数filter和map
14. 冗赘的元素：某个对象中只有几个元素或一两个方法，可以将其与其他类合并
15. 夸夸其谈通用性：尽量少为“不久的将来”预留
16. 临时字段：减少临时变量
17. 过长的消息链：数据在不同的对象或方法中一直传递
18. 中间人：减少中间人的使用

## 第四章 构筑测试体系

优良的测试程序可以提高编程速度。

#### 自测试代码的价值

- 如果想重构，就必须编写测试
- 频繁的运行测试，对于正在处理的代码，与其对应的测试至少每隔几分钟就运行一次测试，每天至少运行一次所有测试

在测试时尽量避免共享变量

考虑可能出错的边界条件，把测试火力集中在那，不要因为测试无法捕捉所有的bug就不写测试，因为测试可以捕捉到大多数bug。

一个架构的好坏，很大程度取决于可观侧性，每当有一个bug报告时，先写一个测试暴露，当测试改动比代码改动要多时，可以先优化测试。

## 第五章 重构的名录

包含名称，速写，动机做法和范例

## 第六章 第一组重构

1. **提炼函数**
   1. 创造一个新函数，根据这个函数的意图来对它命名。以它“做什么”来命名，而不是以它“怎么做”命名。
2. **内联函数**
   1. 内联函数在父函数中使用父函数的作用域，合并过细的函数为整体。
3. **提炼变量**
   1. 将表达式分解为比较容易管理的形式，如拆分为局部变量。
4. **内联变量**
   1. 减少无意义的变量，直接使用表达式或方法
5. **改变函数声明**
   1. 将小函数组合在一起，并为函数取一个合适的名字。
6. **封装变量**
   1. 创建封装函数，在其中访问和更新变量值，应用越广，越应该对变量封装
7. **变量改名**：见名知意。
8. **引入参数对象**
   1. 当一组数据项总是一起出现时，使用对象进行封装
9. **函数组合成类**：
   1. 运用封装记录对多个函数共用的数据进行封装
10. **函数组合变换**
    1. 将计算派生数据的逻辑收拢到一处
11. **拆分阶段**
    1. 一段代码处理不同事时，拆分为独立的模块

## 第七章 封装对入口统一

1. **封装记录**
   1. 对持有记录的变量封装到一个函数中，使用取值函数来封装对数据的深层查找，更新数据时用对象包装结构。
2. **封装集合**
   1. 对象的复杂属性如集合类型修改时应该封装好**添加**和**移除**方法，将入口统一。
3. **以对象取代基本类型**
   1. 对某个数据的操作不仅仅局限于打印时，此时可以创建一个新类取代基本类型
4. **以查询取代临时变量**
   1. 对临时变量进行封装
5. **提炼类**
   1. 一个类应该有一个清晰的抽象，只处理一些明确的责任，如果一个类负责的功能太多，需要拆分开
6. **内联类**
   1. 如果一个类不再承担责任，不再有单独存在的理由，则将其与其他类合并
7. **隐藏委托关系**
   1. 使用封装减少业务方直接使用委托关系
8. **移除中间人**
   1. 如果简单委托关系太多时，服务类完全变成了中间人，此时应该直接调用委托类，删除掉中间人
9. **替换算法**
   1. 如果某个算法没有存在的理由时，则使用简单的算法替代它

## 第八章 搬移特性

1. **搬移函数**
   1. 将一个函数搬移到与它关系更密切的地方（其他类中）
2. **搬移字段**
   1. 将一个字段搬移到其他类中
3. **搬移语句到函数**
   1. 如果某些语句经常跟一个函数一起变动，可以将语句移动到函数中
4. **搬移语句到调用者**
   1. 如果函数的某个行为在不同的调用者中有区别，可以将行为拆分到不同的调用者中
5. **以函数调用取代内联函数**
   1. 将内联代码替代为一个对既有函数的调用
6. **移动语句**
   1. 让存在关联的东西一起出现，如果有几行代码采用了同一个数据结构，最好让他们在一起出现
7. **拆分循环**
   1. 在一次循环中尽量只做一件事情，将循环中的代码拆分，这样在修改时只需要理解要修改的代码。拆分循环实际上很少影响性能。
8. **以管道取代循环**
   1. 使用map、filter等高阶函数改造循环
9. **移除死代码**
   1. 如果代码没用时，可以直接删除代码。如果需要的时候，可以在版本控制中找回。实际上被删除的代码基本不会再被用到。

## 第9章 重新组织数据

1. **拆分变量**
   1. 如果某个变量被赋值超过一次，应该被拆分为多个变量，每个变量只承担一个责任
2. **字段改名**
   1. 将一些通用变量改为更具体的变量名称，例如将name改为title
3. **以查询取代派生变量**
   1. 尽量把可变数据的作用域限制在最小范围
4. **将引用对象改为值对象**
   1. 如果想保证某个值不被其他地方修改时，则将引用对象改为值对象，值对象不可修改
5. **将值对象改为引用对象**
   1. 如果多个记录使用同一个对象，使用值对象会创建很多对象，并且被引用的对象更新时，其他的值要附带更新，此时可以使用值对象来替代引用对象

## 第10章 简化条件循环

1. **分解条件表达式**
   1. 将复杂条件表达式分解为多个独立的函数，根据每个小块代码的用途为分解而得的新函数命名
2. **合并表达式**
   1. 如果表达式的最终行为一致，可以用逻辑与或逻辑或合并，并进行函数提炼
3. **以卫语句取代嵌套表达式**
   1. 卫语句：如果某个分支极其罕见，就应该单独检查该条件，并在为真时立刻从函数中返回，从而减少嵌套循环的长度
4. **以多态取代条件表达式**
   1. 使用多态取代if、else和switch、case
5. **引入特性**
   1. 如果代码有多处以同样方式应对同一个特殊值，就需要创建一个特例元素，用以表达对这种特例的共同行为处理
6. **引入断言**
   1. 如果代码中假设某个条件始终为真，就加入一个断言明确说明这种情况

## 第11章 重构API

1. **将查询函数和修改函数分离**
   1. 任何有返回值的函数都不应该有看得到的副作用：命令与查询分离。
2. **函数参数化**
   1. 如果两个函数逻辑非常相似，只有一些字面量值不同，可以将其合并为一个函数，以参数形式传入不同值。
3. **移除标记参数**
   1. 标记参数：调用者用它来指示被调用函数应该执行哪一部分逻辑。此时应该把不同的逻辑拆分为不同的判断
4. **保持完整对象**
   1. 如果某个函数的参数只是某个对象的一部分，可以从多个参数改为只传入对象，缩小传参的个数。
5. **以查询取代参数**
   1. 函数的参数列表应该总结表现函数的可变性。标识出函数可能体现出行为差异的主要表现形式。参数列表应该尽量避免重复，并且越短越容易理解。如果想要去除的参数值只要向另一个参数查询就能获得，则将这个参数删掉，查过查询另一个参数获取。
6. **以参数取代查询**
   1. 如果需要改变代码的依赖关系时，需要进行反向重构，将依赖关系改为参数列表传入。
7. **移除设值函数**
   1. 如果想清晰表达某个类的值不能被修改，就移除该值的设值函数，在初始化时进行设值
8. **以工厂函数取代构造函数**
   1. 如果构造函数区分度不高时，可以用工厂函数取代函数进行创建对象
9. **以命令取代函数**
   1. 使用命令对象取代基本函数，进行更丰富的操作和生命周期管理
10. **以函数取代命令**
    1. 如果命令对象使用的对象只有一个简单函数，这时候就可以将命令对象改为普通函数

## 第12章 处理继承关系

1. **函数上移**
   1. 如果某个函数在各个子类中行为都相同，则将该函数提到父类中
2. **字段上移**
   1. 将重复的属性提到父类中
3. **构造函数本体上移**
   1. 将构造函数的一些共性行为提到父类中
4. **函数下移**
   1. 如果超类中某个函数只与某个子类有关系，可以将函数下移到子类中
5. **字段下移**
   1. 如果某个字段只被一个子类或小部分子类用到，就将其搬移到需要该字段的子类中
6. **以子类取代类型码**
   1. 通过多态来处理条件逻辑
7. **移除子类**
   1. 如果子类的功能太小，此时可以移除，用超类取代他
8. **提炼超类**
   1. 如果两个类在做相似的事，可以用基本继承机制把相似之处提炼为超类
9. **折叠继承体系**
   1. 如果一个类与其超类已经没太大的差别，此时可以把超类和子类合并
10. **以委托取代超类**
    1. 继承只能用于处理一个方向的变化，如年轻人、老年人，穷人和富人多种差异时，不适合使用两种继承关系，此时可以用委托取代子类。
    2. 对象组合优于继承：审慎的组合使用对象组合与类继承，优于单独地使用其中任何一种
11. **以委托取代超类**
    1. 如果超类的一些函数对其子类并不使用，说明不应该通过继承获得超类的功能
    2. 除了“子类用得上超类的所有函数之外”，合理的继承关系还有一个重要的特征：子类的所有实例都应该是超类的实例。通过超类的接口使用子类完全不会出现任何问题。
    3. 如果子类与超类之间耦合性太强，超类的变化很容易破坏子类的功能，此时可以使用委托取代超类